Collections.sort List的sort 内部会将链表转成数组，调用Arrays.sort，最后转回链表
数组排序总体要比链表快，省去了指针的改变，操作更灵活，数组用下标赋值即可 可以随意前到后 后到前
Arrays.sort 是JDK的排序实现
    基本类型：
        数据量少 -- 插入排序
        数据量适中 -- 快速排序
        海量数据 -- 根据无序程度来判定继续使用哪种算法
            基本无序 -- 快速排序
            基本有序 -- 归并排序
    Object类型：
        少量数据 -- 插入排序
        大量数据 -- 归并排序

为何在数据量少时选择插入？
    冒泡、选择、插入虽然O(N2)，但O(N2)代表的是数据上涨耗时的趋势，当数据量少时速度反而更快
    希尔在数据量少时再分步拆多此一举，归并、快速还要递归开栈 出栈入栈额外消耗时间，投入产出比很低

排序选择考虑点：
    时间复杂度、空间复杂度、稳定性、比较和交换次数、是顺序还是跳跃访问

插入 vs 冒泡 vs 选择
    它三都是原地排序(空间复杂度O(1)),时间复杂度一样，但是
    插入 vs 冒泡：
        冒泡每次从头到尾比较一次涉及三次赋值，而插入只需要一次赋值，高下立判
    插入 vs 选择：
        插入是稳定排序且在数据基本有序时特别快，相比之下自然插入更好
    所以在O(N2)世界里，真正有应用的只有插入，冒泡和选择就只是停留在理论书本了

当数据量到达一定量级，O(NlogN)就要比O(N2)快很多，此时就面临二选一的情况

时间复杂度怎么计算的？
   处理次数 * 每次处理涉及的元素数量
   上面三个都是N次， 虽然每次处理元素个数为[1-N],总体算是N2
   快排：最好是每次递归切分点都是中间，处理次数为logN，最差每次切分点都是最左or最右，处理次数是N
   归并：每次都是中间切分递归，恒定是logN - 每次处理N个元素 总体是NlogN
   堆排序：先构建堆(每个元素上浮or下沉 次数为树高logN) NlogN ， 然后基于堆不断交换首尾并重建堆结构，一共N次 NlogN+NlogN

快速 vs 归并 vs 堆排序：
    快速平均情况下最快(虽然极端情况下会是O(N2)但几乎不会出现)
    归并稳定，但是每次都要申请一个额外空间，将数据合并到那，然后再移动回去，并销毁额外空间，这部分操作很耗时也很耗内存
    堆排序虽说也是O(NlogN)，但要先建堆再一步步首尾替换重构堆完成排序简直了
      堆排序只适用少量场景(TopK 比快排更省内存)，而且它是跳跃访问，对缓存也不友好

看起来无脑选快排就好，怎么还有归并的事情？
    归并特点是稳定且总体比较次数少于快排(尤其是有序度高的时候)
    所以JDK在 数据量大 && (类型Object || 有序度高)选择归并

归并核心思想：
 一次将数据完全打散成单元素，之后俩俩有序数据集做有序合并(此时需要额外等价存储空间作为临时数据存储)
 且合并过程中一个处理完了(此时两个需要比较选取小的先进临时存储)，另一个则无脑加入临时存储即可，省去部分比较且有序性越高省的越多

快排核心思想：
 每次先通过整体比较确认递归切分点，而后每次递归仍旧需要全部比较一次直到递归数据集为1，优点是不需要额外临时存储空间
 可见跟归并比较：很省空间，只有必要情况才移动数据(归并是所有都要移动到临时存储再移动回来)
 这也是通常情况快排优于归并的主要原因，要知道每次额外开辟销毁 数据移来移去是很耗费时间资源的
 而归并的特点是它稳定 这对对象类型至关重要 且其比较次数相对较少(对象比较耗时也很可观)
 尤其在数据有序高时能省去大量比较，所以这也是为何JDK在某些情况下选择归并的原因

非交换排序： 桶排序、计数排序、基数排序
 上面(冒泡、选择、插入、希尔、堆、归并、快排)都是基于比较来进行排序，时间复杂度从O(N2)-O(NlogN)
 而这三种是非交换的且时间复杂度达到了常数级，但应用场景有限

比较类型适用于任何规模，任何分步情况，任何类型(只要可以比较)的数据排序

桶排序：
 把数组元素按照范围划分到n个容量相同的子桶，每个桶各自进行排序，最后合并成有序结果
 桶排序要求分配算法要使得数据分布必须均匀，否则可能导致数据都集中到一个桶中

为什么桶排序时间复杂度可以看作是O(N)?
 假设数据均匀分布，每个桶的元素平均个数为n/k,假设用快排序对桶内元素排序，那么每次排序的时间复杂度为O(n/klog(n/k))
 总时间复杂度为 O(n)+O(k)O(n/klog(n/k)) = O(n+nlog(n/k)) = O(n+nlogn-nlogk)
 当k接近于n时，桶排序的时间复杂度就可以近似认为是O(n) 即桶越多，时间效率就越高，而桶越多，空间也就越大

应用场景：
 现在给你100G数据，给你一个8核1G内存机器，如何最快完成排序？
 可见内存已经无法一次性加载所有数据，此时将数据按照算法范围分桶，使得每个桶都可以加载到内存，而后每个桶使用快排
 剩下就是选择什么分配算法又快又均匀？ 分多少桶最佳？
 要知道桶数不是越多越好，少肯定也不行，分配申请桶销毁 合并 路由都是有损耗的 需要不断根据数据特性进行实验达到最佳点
 分配算法有个有意思的思路：用位运算只提取最高8位，那就有2的八次方 用&运算指向不同的桶 这个方法还挺快

计数排序：
 开一个长度为 max-min+1 的数组，然后扫描一遍原始数组，以 当前值-minValue 作为下标，将该下标的计数器增1
 之后扫描一遍计数器数组，按顺序把值收集起来得到结果就是有序集合，是一种特殊的桶排序
 虽然是O(N),但场景有限：仅适用于数据比较集中的情况。若是这种[0100],[1000019999] 会造成空间巨大浪费

基数排序：
 提取数据里最大值的最高位maxBit，从0->maxBit 或 maxBit->0 迭代，
 每次先轮训array提取元素对应位录入二维数组对应位置,然后遍历二维数组放回array
 要求数据可以划分成高低位，位之间有递进关系而且每一位的数据范围不能太大(不过一般都是十进制、十六进制比较)





