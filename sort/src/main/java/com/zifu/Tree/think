二叉树
四种遍历要熟练掌握，很多树的题目都是依靠四大遍历来做

DFS(先序、中序、后序) 三大类写法(递归、迭代、莫里斯)
递归
  最好写，时间复杂度O(N),空间负责度O(logN) N为树节点数，logN为树高度
  递归通过方法调用栈完成先进后出
迭代
  自己手动维护栈完成先进先出，时间和空间复杂度在公式上虽然看起来一样
  但是递归栈每次操作涉及的数据和处理都是很重的，所以其实迭代从时间和空间都优于递归(复杂度分析有时候常数也不可忽略)

莫里斯
  完全摒弃栈，利用将当前节点左子树的最右叶节点的右空闲指针同其挂载，来完成识别节点第几次遍历和回溯，空间复杂度降为O(1)
  有些题目要求O(1)的空间复杂度遍历树时 其实就需要你用莫里斯遍历来实现

迭代前序很简单，因为每个节点就是一进一出，而中序和后序需要先穷举node的左子树左节点入栈
这里注意需要一个cur (cur = root or node.right) 和 stack完成，因为一个stack不足以完成穷举入栈，会陷入死循环，
前序只需stack即可,另外不同的是后序需要再依靠一个pre来让node确实是最后弹出(pre==node.right 才弹出)

莫里斯相当于双指针操作，每次先找到node左子树最右叶子的right同其挂载，完成左子树遍历后回溯回去
同时根据right==null来判断node是第几次，前中后框架一样
p1 = root , p2 = null;
while (p1 != null) {
  p2 = p1.left;
  if (p2 != null) {
    while (p2.right != null && p2.right != p1) {
      p2 = p2.right;
    }
    if (p2.right ==null) {
      //前序在挂载前输出node.val
      p2.right = p1;
      p1 = p1.left;
      continue;
    } else {
      //中序在解除挂载前输出node.val
      //后序在解除挂载前 将p1.left到p2之间节点反转打印(是以right连接的链表结构)，之后再反转回来
      //另外还需要一个dummy根节点，其left=root，这样才能完成最上层的逆序输出
      p2.right = null;
      p1 = p1.right;
    }
  } else {
    //此处代表为无左子树，前序中序这里输出node.val
    p1 = p1.right;
  }
}


空间复杂度是O(1), 但是时间复杂度却上升了不少(公式虽然是O(N) 但每个节点往往还涉及遍历左子树右侧
尤其是后序遍历 还涉及链表反转这种操作 所以当对空间复杂度没有O(1)要求 我认为迭代最好 继而是莫里斯 最后是递归)


BFS层序遍历（广度优先搜索）基于队列(Queue - LinkedList)完成，有很多题目都是基于BFS

DFS中序遍历二叉搜索树结果为升序：二叉搜索树很多题目都跟这个特性有关
另外要注意递归特性是每次拿到左右两部分和cur，迭代能拿到pre和cur
譬如验证二叉搜索树，迭代要用中序，递归要用后序
有很多算法必须用迭代DFS，所以一定要掌握三种迭代模式

1 验证二叉搜索树(中序迭代 or 后序递归 特点是node大于所有左子树节点 小于所有右子树节点)
2 恢复二叉搜索树(O(1)用莫里斯)
3 前序+中序 或 后序+中序 遍历结果 构造二叉树
(递归 注意参数为两数组和各自下标(start,end)，可不是每次新创建子数组，每次都重新算length)
4 生序数组或链表构造二叉搜索树
(递归 数组用nums+start+end索引下标 中点=(start+end)/2 链表用left、right节点 中点=快慢指针所得)
5 二叉树最小 最大 深度